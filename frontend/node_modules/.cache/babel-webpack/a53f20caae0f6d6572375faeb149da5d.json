{"ast":null,"code":"'use strict';\n\nvar helpers = require('../helpers/index');\n\nvar Ticks = require('../core/core.ticks');\n\nmodule.exports = function (Chart) {\n  var defaultConfig = {\n    position: 'left',\n    // label settings\n    ticks: {\n      callback: Ticks.formatters.logarithmic\n    }\n  };\n  var LogarithmicScale = Chart.Scale.extend({\n    determineDataLimits: function determineDataLimits() {\n      var me = this;\n      var opts = me.options;\n      var tickOpts = opts.ticks;\n      var chart = me.chart;\n      var data = chart.data;\n      var datasets = data.datasets;\n      var valueOrDefault = helpers.valueOrDefault;\n      var isHorizontal = me.isHorizontal();\n\n      function IDMatches(meta) {\n        return isHorizontal ? meta.xAxisID === me.id : meta.yAxisID === me.id;\n      } // Calculate Range\n\n\n      me.min = null;\n      me.max = null;\n      me.minNotZero = null;\n      var hasStacks = opts.stacked;\n\n      if (hasStacks === undefined) {\n        helpers.each(datasets, function (dataset, datasetIndex) {\n          if (hasStacks) {\n            return;\n          }\n\n          var meta = chart.getDatasetMeta(datasetIndex);\n\n          if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta) && meta.stack !== undefined) {\n            hasStacks = true;\n          }\n        });\n      }\n\n      if (opts.stacked || hasStacks) {\n        var valuesPerStack = {};\n        helpers.each(datasets, function (dataset, datasetIndex) {\n          var meta = chart.getDatasetMeta(datasetIndex);\n          var key = [meta.type, // we have a separate stack for stack=undefined datasets when the opts.stacked is undefined\n          opts.stacked === undefined && meta.stack === undefined ? datasetIndex : '', meta.stack].join('.');\n\n          if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {\n            if (valuesPerStack[key] === undefined) {\n              valuesPerStack[key] = [];\n            }\n\n            helpers.each(dataset.data, function (rawValue, index) {\n              var values = valuesPerStack[key];\n              var value = +me.getRightValue(rawValue);\n\n              if (isNaN(value) || meta.data[index].hidden) {\n                return;\n              }\n\n              values[index] = values[index] || 0;\n\n              if (opts.relativePoints) {\n                values[index] = 100;\n              } else {\n                // Don't need to split positive and negative since the log scale can't handle a 0 crossing\n                values[index] += value;\n              }\n            });\n          }\n        });\n        helpers.each(valuesPerStack, function (valuesForType) {\n          var minVal = helpers.min(valuesForType);\n          var maxVal = helpers.max(valuesForType);\n          me.min = me.min === null ? minVal : Math.min(me.min, minVal);\n          me.max = me.max === null ? maxVal : Math.max(me.max, maxVal);\n        });\n      } else {\n        helpers.each(datasets, function (dataset, datasetIndex) {\n          var meta = chart.getDatasetMeta(datasetIndex);\n\n          if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {\n            helpers.each(dataset.data, function (rawValue, index) {\n              var value = +me.getRightValue(rawValue);\n\n              if (isNaN(value) || meta.data[index].hidden) {\n                return;\n              }\n\n              if (me.min === null) {\n                me.min = value;\n              } else if (value < me.min) {\n                me.min = value;\n              }\n\n              if (me.max === null) {\n                me.max = value;\n              } else if (value > me.max) {\n                me.max = value;\n              }\n\n              if (value !== 0 && (me.minNotZero === null || value < me.minNotZero)) {\n                me.minNotZero = value;\n              }\n            });\n          }\n        });\n      }\n\n      me.min = valueOrDefault(tickOpts.min, me.min);\n      me.max = valueOrDefault(tickOpts.max, me.max);\n\n      if (me.min === me.max) {\n        if (me.min !== 0 && me.min !== null) {\n          me.min = Math.pow(10, Math.floor(helpers.log10(me.min)) - 1);\n          me.max = Math.pow(10, Math.floor(helpers.log10(me.max)) + 1);\n        } else {\n          me.min = 1;\n          me.max = 10;\n        }\n      }\n    },\n    buildTicks: function buildTicks() {\n      var me = this;\n      var opts = me.options;\n      var tickOpts = opts.ticks;\n      var generationOptions = {\n        min: tickOpts.min,\n        max: tickOpts.max\n      };\n      var ticks = me.ticks = Ticks.generators.logarithmic(generationOptions, me);\n\n      if (!me.isHorizontal()) {\n        // We are in a vertical orientation. The top value is the highest. So reverse the array\n        ticks.reverse();\n      } // At this point, we need to update our max and min given the tick values since we have expanded the\n      // range of the scale\n\n\n      me.max = helpers.max(ticks);\n      me.min = helpers.min(ticks);\n\n      if (tickOpts.reverse) {\n        ticks.reverse();\n        me.start = me.max;\n        me.end = me.min;\n      } else {\n        me.start = me.min;\n        me.end = me.max;\n      }\n    },\n    convertTicksToLabels: function convertTicksToLabels() {\n      this.tickValues = this.ticks.slice();\n      Chart.Scale.prototype.convertTicksToLabels.call(this);\n    },\n    // Get the correct tooltip label\n    getLabelForIndex: function getLabelForIndex(index, datasetIndex) {\n      return +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);\n    },\n    getPixelForTick: function getPixelForTick(index) {\n      return this.getPixelForValue(this.tickValues[index]);\n    },\n    getPixelForValue: function getPixelForValue(value) {\n      var me = this;\n      var start = me.start;\n      var newVal = +me.getRightValue(value);\n      var opts = me.options;\n      var tickOpts = opts.ticks;\n      var innerDimension, pixel, range;\n\n      if (me.isHorizontal()) {\n        range = helpers.log10(me.end) - helpers.log10(start); // todo: if start === 0\n\n        if (newVal === 0) {\n          pixel = me.left;\n        } else {\n          innerDimension = me.width;\n          pixel = me.left + innerDimension / range * (helpers.log10(newVal) - helpers.log10(start));\n        }\n      } else {\n        // Bottom - top since pixels increase downward on a screen\n        innerDimension = me.height;\n\n        if (start === 0 && !tickOpts.reverse) {\n          range = helpers.log10(me.end) - helpers.log10(me.minNotZero);\n\n          if (newVal === start) {\n            pixel = me.bottom;\n          } else if (newVal === me.minNotZero) {\n            pixel = me.bottom - innerDimension * 0.02;\n          } else {\n            pixel = me.bottom - innerDimension * 0.02 - innerDimension * 0.98 / range * (helpers.log10(newVal) - helpers.log10(me.minNotZero));\n          }\n        } else if (me.end === 0 && tickOpts.reverse) {\n          range = helpers.log10(me.start) - helpers.log10(me.minNotZero);\n\n          if (newVal === me.end) {\n            pixel = me.top;\n          } else if (newVal === me.minNotZero) {\n            pixel = me.top + innerDimension * 0.02;\n          } else {\n            pixel = me.top + innerDimension * 0.02 + innerDimension * 0.98 / range * (helpers.log10(newVal) - helpers.log10(me.minNotZero));\n          }\n        } else if (newVal === 0) {\n          pixel = tickOpts.reverse ? me.top : me.bottom;\n        } else {\n          range = helpers.log10(me.end) - helpers.log10(start);\n          innerDimension = me.height;\n          pixel = me.bottom - innerDimension / range * (helpers.log10(newVal) - helpers.log10(start));\n        }\n      }\n\n      return pixel;\n    },\n    getValueForPixel: function getValueForPixel(pixel) {\n      var me = this;\n      var range = helpers.log10(me.end) - helpers.log10(me.start);\n      var value, innerDimension;\n\n      if (me.isHorizontal()) {\n        innerDimension = me.width;\n        value = me.start * Math.pow(10, (pixel - me.left) * range / innerDimension);\n      } else {\n        // todo: if start === 0\n        innerDimension = me.height;\n        value = Math.pow(10, (me.bottom - pixel) * range / innerDimension) / me.start;\n      }\n\n      return value;\n    }\n  });\n  Chart.scaleService.registerScaleType('logarithmic', LogarithmicScale, defaultConfig);\n};","map":{"version":3,"sources":["/home/basis/template/p-lc-aprd_codigo_fonte/client/node_modules/chart.js/src/scales/scale.logarithmic.js"],"names":["helpers","require","Ticks","module","exports","Chart","defaultConfig","position","ticks","callback","formatters","logarithmic","LogarithmicScale","Scale","extend","determineDataLimits","me","opts","options","tickOpts","chart","data","datasets","valueOrDefault","isHorizontal","IDMatches","meta","xAxisID","id","yAxisID","min","max","minNotZero","hasStacks","stacked","undefined","each","dataset","datasetIndex","getDatasetMeta","isDatasetVisible","stack","valuesPerStack","key","type","join","rawValue","index","values","value","getRightValue","isNaN","hidden","relativePoints","valuesForType","minVal","maxVal","Math","pow","floor","log10","buildTicks","generationOptions","generators","reverse","start","end","convertTicksToLabels","tickValues","slice","prototype","call","getLabelForIndex","getPixelForTick","getPixelForValue","newVal","innerDimension","pixel","range","left","width","height","bottom","top","getValueForPixel","scaleService","registerScaleType"],"mappings":"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","sourcesContent":["'use strict';\n\nvar helpers = require('../helpers/index');\nvar Ticks = require('../core/core.ticks');\n\nmodule.exports = function(Chart) {\n\n\tvar defaultConfig = {\n\t\tposition: 'left',\n\n\t\t// label settings\n\t\tticks: {\n\t\t\tcallback: Ticks.formatters.logarithmic\n\t\t}\n\t};\n\n\tvar LogarithmicScale = Chart.Scale.extend({\n\t\tdetermineDataLimits: function() {\n\t\t\tvar me = this;\n\t\t\tvar opts = me.options;\n\t\t\tvar tickOpts = opts.ticks;\n\t\t\tvar chart = me.chart;\n\t\t\tvar data = chart.data;\n\t\t\tvar datasets = data.datasets;\n\t\t\tvar valueOrDefault = helpers.valueOrDefault;\n\t\t\tvar isHorizontal = me.isHorizontal();\n\t\t\tfunction IDMatches(meta) {\n\t\t\t\treturn isHorizontal ? meta.xAxisID === me.id : meta.yAxisID === me.id;\n\t\t\t}\n\n\t\t\t// Calculate Range\n\t\t\tme.min = null;\n\t\t\tme.max = null;\n\t\t\tme.minNotZero = null;\n\n\t\t\tvar hasStacks = opts.stacked;\n\t\t\tif (hasStacks === undefined) {\n\t\t\t\thelpers.each(datasets, function(dataset, datasetIndex) {\n\t\t\t\t\tif (hasStacks) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar meta = chart.getDatasetMeta(datasetIndex);\n\t\t\t\t\tif (chart.isDatasetVisible(datasetIndex) && IDMatches(meta) &&\n\t\t\t\t\t\tmeta.stack !== undefined) {\n\t\t\t\t\t\thasStacks = true;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (opts.stacked || hasStacks) {\n\t\t\t\tvar valuesPerStack = {};\n\n\t\t\t\thelpers.each(datasets, function(dataset, datasetIndex) {\n\t\t\t\t\tvar meta = chart.getDatasetMeta(datasetIndex);\n\t\t\t\t\tvar key = [\n\t\t\t\t\t\tmeta.type,\n\t\t\t\t\t\t// we have a separate stack for stack=undefined datasets when the opts.stacked is undefined\n\t\t\t\t\t\t((opts.stacked === undefined && meta.stack === undefined) ? datasetIndex : ''),\n\t\t\t\t\t\tmeta.stack\n\t\t\t\t\t].join('.');\n\n\t\t\t\t\tif (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {\n\t\t\t\t\t\tif (valuesPerStack[key] === undefined) {\n\t\t\t\t\t\t\tvaluesPerStack[key] = [];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\thelpers.each(dataset.data, function(rawValue, index) {\n\t\t\t\t\t\t\tvar values = valuesPerStack[key];\n\t\t\t\t\t\t\tvar value = +me.getRightValue(rawValue);\n\t\t\t\t\t\t\tif (isNaN(value) || meta.data[index].hidden) {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tvalues[index] = values[index] || 0;\n\n\t\t\t\t\t\t\tif (opts.relativePoints) {\n\t\t\t\t\t\t\t\tvalues[index] = 100;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// Don't need to split positive and negative since the log scale can't handle a 0 crossing\n\t\t\t\t\t\t\t\tvalues[index] += value;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\thelpers.each(valuesPerStack, function(valuesForType) {\n\t\t\t\t\tvar minVal = helpers.min(valuesForType);\n\t\t\t\t\tvar maxVal = helpers.max(valuesForType);\n\t\t\t\t\tme.min = me.min === null ? minVal : Math.min(me.min, minVal);\n\t\t\t\t\tme.max = me.max === null ? maxVal : Math.max(me.max, maxVal);\n\t\t\t\t});\n\n\t\t\t} else {\n\t\t\t\thelpers.each(datasets, function(dataset, datasetIndex) {\n\t\t\t\t\tvar meta = chart.getDatasetMeta(datasetIndex);\n\t\t\t\t\tif (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {\n\t\t\t\t\t\thelpers.each(dataset.data, function(rawValue, index) {\n\t\t\t\t\t\t\tvar value = +me.getRightValue(rawValue);\n\t\t\t\t\t\t\tif (isNaN(value) || meta.data[index].hidden) {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (me.min === null) {\n\t\t\t\t\t\t\t\tme.min = value;\n\t\t\t\t\t\t\t} else if (value < me.min) {\n\t\t\t\t\t\t\t\tme.min = value;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (me.max === null) {\n\t\t\t\t\t\t\t\tme.max = value;\n\t\t\t\t\t\t\t} else if (value > me.max) {\n\t\t\t\t\t\t\t\tme.max = value;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (value !== 0 && (me.minNotZero === null || value < me.minNotZero)) {\n\t\t\t\t\t\t\t\tme.minNotZero = value;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tme.min = valueOrDefault(tickOpts.min, me.min);\n\t\t\tme.max = valueOrDefault(tickOpts.max, me.max);\n\n\t\t\tif (me.min === me.max) {\n\t\t\t\tif (me.min !== 0 && me.min !== null) {\n\t\t\t\t\tme.min = Math.pow(10, Math.floor(helpers.log10(me.min)) - 1);\n\t\t\t\t\tme.max = Math.pow(10, Math.floor(helpers.log10(me.max)) + 1);\n\t\t\t\t} else {\n\t\t\t\t\tme.min = 1;\n\t\t\t\t\tme.max = 10;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tbuildTicks: function() {\n\t\t\tvar me = this;\n\t\t\tvar opts = me.options;\n\t\t\tvar tickOpts = opts.ticks;\n\n\t\t\tvar generationOptions = {\n\t\t\t\tmin: tickOpts.min,\n\t\t\t\tmax: tickOpts.max\n\t\t\t};\n\t\t\tvar ticks = me.ticks = Ticks.generators.logarithmic(generationOptions, me);\n\n\t\t\tif (!me.isHorizontal()) {\n\t\t\t\t// We are in a vertical orientation. The top value is the highest. So reverse the array\n\t\t\t\tticks.reverse();\n\t\t\t}\n\n\t\t\t// At this point, we need to update our max and min given the tick values since we have expanded the\n\t\t\t// range of the scale\n\t\t\tme.max = helpers.max(ticks);\n\t\t\tme.min = helpers.min(ticks);\n\n\t\t\tif (tickOpts.reverse) {\n\t\t\t\tticks.reverse();\n\n\t\t\t\tme.start = me.max;\n\t\t\t\tme.end = me.min;\n\t\t\t} else {\n\t\t\t\tme.start = me.min;\n\t\t\t\tme.end = me.max;\n\t\t\t}\n\t\t},\n\t\tconvertTicksToLabels: function() {\n\t\t\tthis.tickValues = this.ticks.slice();\n\n\t\t\tChart.Scale.prototype.convertTicksToLabels.call(this);\n\t\t},\n\t\t// Get the correct tooltip label\n\t\tgetLabelForIndex: function(index, datasetIndex) {\n\t\t\treturn +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);\n\t\t},\n\t\tgetPixelForTick: function(index) {\n\t\t\treturn this.getPixelForValue(this.tickValues[index]);\n\t\t},\n\t\tgetPixelForValue: function(value) {\n\t\t\tvar me = this;\n\t\t\tvar start = me.start;\n\t\t\tvar newVal = +me.getRightValue(value);\n\t\t\tvar opts = me.options;\n\t\t\tvar tickOpts = opts.ticks;\n\t\t\tvar innerDimension, pixel, range;\n\n\t\t\tif (me.isHorizontal()) {\n\t\t\t\trange = helpers.log10(me.end) - helpers.log10(start); // todo: if start === 0\n\t\t\t\tif (newVal === 0) {\n\t\t\t\t\tpixel = me.left;\n\t\t\t\t} else {\n\t\t\t\t\tinnerDimension = me.width;\n\t\t\t\t\tpixel = me.left + (innerDimension / range * (helpers.log10(newVal) - helpers.log10(start)));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Bottom - top since pixels increase downward on a screen\n\t\t\t\tinnerDimension = me.height;\n\t\t\t\tif (start === 0 && !tickOpts.reverse) {\n\t\t\t\t\trange = helpers.log10(me.end) - helpers.log10(me.minNotZero);\n\t\t\t\t\tif (newVal === start) {\n\t\t\t\t\t\tpixel = me.bottom;\n\t\t\t\t\t} else if (newVal === me.minNotZero) {\n\t\t\t\t\t\tpixel = me.bottom - innerDimension * 0.02;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpixel = me.bottom - innerDimension * 0.02 - (innerDimension * 0.98 / range * (helpers.log10(newVal) - helpers.log10(me.minNotZero)));\n\t\t\t\t\t}\n\t\t\t\t} else if (me.end === 0 && tickOpts.reverse) {\n\t\t\t\t\trange = helpers.log10(me.start) - helpers.log10(me.minNotZero);\n\t\t\t\t\tif (newVal === me.end) {\n\t\t\t\t\t\tpixel = me.top;\n\t\t\t\t\t} else if (newVal === me.minNotZero) {\n\t\t\t\t\t\tpixel = me.top + innerDimension * 0.02;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpixel = me.top + innerDimension * 0.02 + (innerDimension * 0.98 / range * (helpers.log10(newVal) - helpers.log10(me.minNotZero)));\n\t\t\t\t\t}\n\t\t\t\t} else if (newVal === 0) {\n\t\t\t\t\tpixel = tickOpts.reverse ? me.top : me.bottom;\n\t\t\t\t} else {\n\t\t\t\t\trange = helpers.log10(me.end) - helpers.log10(start);\n\t\t\t\t\tinnerDimension = me.height;\n\t\t\t\t\tpixel = me.bottom - (innerDimension / range * (helpers.log10(newVal) - helpers.log10(start)));\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn pixel;\n\t\t},\n\t\tgetValueForPixel: function(pixel) {\n\t\t\tvar me = this;\n\t\t\tvar range = helpers.log10(me.end) - helpers.log10(me.start);\n\t\t\tvar value, innerDimension;\n\n\t\t\tif (me.isHorizontal()) {\n\t\t\t\tinnerDimension = me.width;\n\t\t\t\tvalue = me.start * Math.pow(10, (pixel - me.left) * range / innerDimension);\n\t\t\t} else { // todo: if start === 0\n\t\t\t\tinnerDimension = me.height;\n\t\t\t\tvalue = Math.pow(10, (me.bottom - pixel) * range / innerDimension) / me.start;\n\t\t\t}\n\t\t\treturn value;\n\t\t}\n\t});\n\tChart.scaleService.registerScaleType('logarithmic', LogarithmicScale, defaultConfig);\n\n};\n"]},"metadata":{},"sourceType":"script"}